<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Multi-Provider AI Chatbot</title>
    <script src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://unpkg.com/redux@4.2.1/dist/redux.min.js"></script>
    <script src="https://unpkg.com/react-redux@8.1.3/dist/react-redux.min.js"></script>
    <script src="https://unpkg.com/@reduxjs/toolkit@1.9.7/dist/redux-toolkit.umd.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap');
        body { font-family: 'Inter', sans-serif; overflow: hidden; }
        .no-scrollbar::-webkit-scrollbar { display: none; }
        .no-scrollbar { -ms-overflow-style: none; scrollbar-width: none; }
        .message-content pre { background-color: #1e293b; color: #e2e8f0; padding: 1rem; border-radius: 0.5rem; overflow-x: auto; margin: 0.5rem 0; }
        .message-content code { font-family: 'Courier New', Courier, monospace; }
        .message-content p { margin-bottom: 0.5rem; }
    </style>
</head>
<body class="bg-gray-900 text-gray-100">
    <div id="root"></div>

    <script type="text/babel">
        const { Provider, useSelector, useDispatch } = ReactRedux;
        const { configureStore, createSlice, createAsyncThunk } = RTK;
        const { useState, useEffect, useRef } = React;

        const API_BASE_URL = 'http://127.0.0.1:8000';

        // --- ASYNC THUNKS ---
        const fetchSessions = createAsyncThunk('chat/fetchSessions', async () => {
            const response = await fetch(`${API_BASE_URL}/sessions`);
            return response.json();
        });

        const createNewSession = createAsyncThunk('chat/createNewSession', async (title) => {
            const response = await fetch(`${API_BASE_URL}/sessions`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ title: title || "New Chat" })
            });
            return response.json();
        });
        
        const fetchSessionDetails = createAsyncThunk('chat/fetchSessionDetails', async (sessionId) => {
            const response = await fetch(`${API_BASE_URL}/sessions/${sessionId}`);
            return response.json();
        });


        // --- REDUX SLICE ---
        const chatSlice = createSlice({
            name: 'chat',
            initialState: {
                sessions: {},
                activeSessionId: null,
                sessionStatus: 'idle', // 'idle' | 'loading' | 'succeeded' | 'failed'
                isStreaming: false,
                currentProvider: 'gemini',
                currentModel: 'gemini-pro',
            },
            reducers: {
                startStream: (state, action) => {
                    const { sessionId, userMessage } = action.payload;
                    state.isStreaming = true;
                    // Optimistically add user message and AI placeholder
                    state.sessions[sessionId].messages.push(userMessage);
                    state.sessions[sessionId].messages.push({ id: `ai-${Date.now()}`, role: 'assistant', content: '' });
                },
                appendStream: (state, action) => {
                    const { sessionId, delta } = action.payload;
                    const session = state.sessions[sessionId];
                    if (session) {
                        const lastMessage = session.messages[session.messages.length - 1];
                        if (lastMessage?.role === 'assistant') {
                            lastMessage.content += delta;
                        }
                    }
                },
                endStream: (state, action) => {
                    // When streaming ends, we fetch the final state from the server
                    // to ensure consistency and get the real message ID.
                    state.isStreaming = false;
                },
                setActiveSessionId: (state, action) => {
                    state.activeSessionId = action.payload;
                },
                 setModelAndProvider: (state, action) => {
                    state.currentProvider = action.payload.provider;
                    state.currentModel = action.payload.model;
                }
            },
            extraReducers: (builder) => {
                builder
                    .addCase(fetchSessions.pending, (state) => {
                        state.sessionStatus = 'loading';
                    })
                    .addCase(fetchSessions.fulfilled, (state, action) => {
                        state.sessionStatus = 'succeeded';
                        state.sessions = action.payload.reduce((acc, session) => {
                            acc[session.id] = { ...session, messages: [] }; // Don't load messages initially
                            return acc;
                        }, {});
                        if (!state.activeSessionId && action.payload.length > 0) {
                            state.activeSessionId = action.payload[0].id;
                        }
                    })
                    .addCase(fetchSessions.rejected, (state) => {
                        state.sessionStatus = 'failed';
                    })
                    .addCase(createNewSession.fulfilled, (state, action) => {
                        const newSession = action.payload;
                        state.sessions[newSession.id] = { ...newSession, messages: [] };
                        state.activeSessionId = newSession.id;
                    })
                    .addCase(fetchSessionDetails.fulfilled, (state, action) => {
                        const sessionDetails = action.payload;
                        state.sessions[sessionDetails.id] = sessionDetails;
                    });
            }
        });

        const { startStream, appendStream, endStream, setActiveSessionId, setModelAndProvider } = chatSlice.actions;

        // --- REDUX STORE ---
        const store = configureStore({ reducer: { chat: chatSlice.reducer } });
        
        // --- API & STREAMING LOGIC ---
        let eventSource = null;

        const streamChatResponse = (payload) => async (dispatch) => {
            const { sessionId, prompt, provider, model } = payload;
            
            const userMessage = { id: `user-${Date.now()}`, role: 'user', content: prompt };
            dispatch(startStream({ sessionId, userMessage }));

            const response = await fetch(`${API_BASE_URL}/chat/stream`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ session_id: sessionId, prompt, provider, model })
            });
            
            const reader = response.body.getReader();
            const decoder = new TextDecoder();

            const processStream = async () => {
                while (true) {
                    const { done, value } = await reader.read();
                    if (done) break;

                    const chunk = decoder.decode(value, { stream: true });
                    const events = chunk.split('\n\n').filter(Boolean);

                    for (const event of events) {
                        if (event.startsWith('data: ')) {
                            const dataStr = event.substring(6);
                            if (dataStr === "[DONE]") {
                                dispatch(endStream());
                                // Fetch final message from server to sync state
                                dispatch(fetchSessionDetails(sessionId)); 
                                return;
                            }
                            try {
                                const data = JSON.parse(dataStr);
                                if (data.delta) {
                                    dispatch(appendStream({ sessionId, delta: data.delta }));
                                }
                                if (data.error) {
                                    console.error("Stream error:", data.error);
                                    dispatch(endStream());
                                    dispatch(fetchSessionDetails(sessionId));
                                    return;
                                }
                            } catch (e) {
                                console.error("JSON parse error", e);
                            }
                        }
                    }
                }
            };
            processStream();
        };
        
        // --- COMPONENTS (Mostly Unchanged, but with updated logic) ---
        const ProviderSelector = () => {
            // ... (Component remains the same as before)
            const dispatch = useDispatch();
            const currentProvider = useSelector(state => state.chat.currentProvider);
            const currentModel = useSelector(state => state.chat.currentModel);
            const [isOpen, setIsOpen] = useState(false);

            const providers = {
                openai: ['gpt-3.5-turbo', 'gpt-4.1'],
                anthropic: ['claude-3-haiku', 'claude-3-sonnet'],
                gemini: ['gemini-pro', 'gemini-flash'],
                ollama: ['llama3', 'mistral']
            };

            const handleSelect = (provider, model) => {
                dispatch(setModelAndProvider({ provider, model }));
                setIsOpen(false);
            };

            return (
                <div className="relative">
                    <button onClick={() => setIsOpen(!isOpen)} className="w-full bg-gray-700 hover:bg-gray-600 text-left px-4 py-2 rounded-lg transition-colors duration-200 flex justify-between items-center">
                        <div>
                            <span className="font-semibold capitalize">{currentProvider}</span>
                            <span className="text-gray-400 ml-2">{currentModel}</span>
                        </div>
                        <svg className={`w-5 h-5 transition-transform duration-200 ${isOpen ? 'transform rotate-180' : ''}`} fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M19 9l-7 7-7-7"></path></svg>
                    </button>
                    {isOpen && (
                        <div className="absolute bottom-full mb-2 w-full bg-gray-800 border border-gray-700 rounded-lg shadow-lg z-10">
                            {Object.entries(providers).map(([provider, models]) => (
                                <div key={provider}>
                                    <h3 className="text-sm font-bold text-gray-400 px-4 pt-3 capitalize">{provider}</h3>
                                    <ul>
                                        {models.map(model => (
                                            <li key={model} onClick={() => handleSelect(provider, model)} className="px-4 py-2 hover:bg-gray-700 cursor-pointer rounded-md">
                                                {model}
                                            </li>
                                        ))}
                                    </ul>
                                </div>
                            ))}
                        </div>
                    )}
                </div>
            );
        };

        const Sidebar = () => {
            const dispatch = useDispatch();
            const sessions = useSelector(state => Object.values(state.chat.sessions));
            const activeSessionId = useSelector(state => state.chat.activeSessionId);
            const sessionStatus = useSelector(state => state.chat.sessionStatus);

            useEffect(() => {
                if (sessionStatus === 'idle') {
                    dispatch(fetchSessions());
                }
            }, [sessionStatus, dispatch]);
            
            const handleSetActive = (sessionId) => {
                dispatch(setActiveSessionId(sessionId));
                dispatch(fetchSessionDetails(sessionId));
            }

            return (
                <div className="w-64 bg-gray-800 h-full flex flex-col p-3">
                    <div className="flex items-center justify-between mb-4">
                        <h1 className="text-xl font-bold">Chat AI</h1>
                        <button onClick={() => dispatch(createNewSession())} className="p-2 rounded-md hover:bg-gray-700">
                            <svg className="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M12 6v6m0 0v6m0-6h6m-6 0H6"></path></svg>
                        </button>
                    </div>
                    <div className="flex-grow overflow-y-auto no-scrollbar pr-1">
                        <p className="text-xs text-gray-500 font-semibold mb-2 px-2">RECENT</p>
                        {sessionStatus === 'loading' && <p>Loading...</p>}
                        {sessions.map(session => (
                            <div key={session.id} onClick={() => handleSetActive(session.id)}
                                className={`truncate px-3 py-2 rounded-md cursor-pointer text-sm mb-1 ${activeSessionId === session.id ? 'bg-gray-700' : 'hover:bg-gray-700/50'}`}>
                                {session.title}
                            </div>
                        ))}
                    </div>
                    <div className="mt-auto">
                        <ProviderSelector />
                    </div>
                </div>
            );
        };

        const ChatMessage = ({ message }) => {
             // ... (Component remains the same as before)
            const isUser = message.role === 'user';
            
            const renderContent = (content) => {
                let html = content
                    .replace(/```([\s\S]*?)```/g, (match, code) => `<pre><code>${code.trim().replace(/</g, "&lt;").replace(/>/g, "&gt;")}</code></pre>`)
                    .replace(/`([^`]+)`/g, `<code>$1</code>`)
                    .replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>')
                    .replace(/\*(.*?)\*/g, '<em>$1</em>')
                    .replace(/\n/g, '<br />');
                
                html = html.replace(/<br \/>\s*(<pre>)/g, '$1').replace(/(<\/pre>)\s*<br \/>/g, '$1');
                return { __html: html };
            };

            return (
                <div className={`flex items-start gap-4 my-4 ${isUser ? 'pr-10' : ''}`}>
                    <div className={`w-8 h-8 rounded-full flex-shrink-0 ${isUser ? 'bg-blue-500' : 'bg-green-500'} flex items-center justify-center font-bold`}>
                        {isUser ? 'U' : 'AI'}
                    </div>
                    <div className="flex-grow mt-1 message-content" dangerouslySetInnerHTML={renderContent(message.content || "")} />
                </div>
            );
        };

        const ChatArea = () => {
            const activeSessionId = useSelector(state => state.chat.activeSessionId);
            const session = useSelector(state => state.chat.sessions[activeSessionId]);
            const messagesEndRef = useRef(null);

            useEffect(() => {
                messagesEndRef.current?.scrollIntoView({ behavior: "smooth" });
            }, [session?.messages]);

            if (!session) {
                return <div className="flex-1 flex items-center justify-center"><p>Select or create a new session.</p></div>;
            }

            return (
                <div className="flex-1 flex flex-col">
                    <div className="flex-grow overflow-y-auto p-6 no-scrollbar">
                        {session.messages.map((msg) => (
                            <ChatMessage key={msg.id} message={msg} />
                        ))}
                        <div ref={messagesEndRef} />
                    </div>
                </div>
            );
        };

        const InputSection = () => {
            const [input, setInput] = useState('');
            const dispatch = useDispatch();
            const isStreaming = useSelector(state => state.chat.isStreaming);
            const activeSessionId = useSelector(state => state.chat.activeSessionId);
            const { currentProvider, currentModel } = useSelector(state => state.chat);

            const handleSend = () => {
                if (input.trim() && !isStreaming && activeSessionId) {
                    dispatch(streamChatResponse({
                        sessionId: activeSessionId,
                        prompt: input,
                        provider: currentProvider,
                        model: currentModel
                    }));
                    setInput('');
                }
            };
            
            // The stop button now has no function as the new streaming logic doesn't use EventSource
            const handleStop = () => console.log("Stop functionality to be re-implemented.");

            const handleKeyDown = (e) => { if (e.key === 'Enter' && !e.shiftKey) { e.preventDefault(); handleSend(); }};

            return (
                <div className="p-6 bg-gray-900">
                    <div className="relative bg-gray-800 border border-gray-700 rounded-lg p-2 flex items-center">
                        <textarea
                            value={input}
                            onChange={(e) => setInput(e.target.value)}
                            onKeyDown={handleKeyDown}
                            placeholder="Type your message..."
                            rows="1"
                            className="w-full bg-transparent resize-none outline-none p-2 no-scrollbar"
                            disabled={isStreaming || !activeSessionId}
                        />
                         {isStreaming ? (
                            <button onClick={handleStop} className="bg-red-500 text-white font-bold py-2 px-4 rounded-md flex items-center" disabled>
                                <svg className="w-4 h-4 mr-2" fill="currentColor" viewBox="0 0 16 16"><path d="M5 3.5h6A1.5 1.5 0 0 1 12.5 5v6a1.5 1.5 0 0 1-1.5 1.5H5A1.5 1.5 0 0 1 3.5 11V5A1.5 1.5 0 0 1 5 3.5z"/></svg>
                                Stop
                            </button>
                        ) : (
                            <button onClick={handleSend} className="bg-blue-500 hover:bg-blue-600 text-white font-bold py-2 px-4 rounded-md" disabled={!input.trim() || !activeSessionId}>
                                Send
                            </button>
                        )}
                    </div>
                </div>
            );
        };

        const App = () => (
            <div className="flex h-screen w-screen">
                <Sidebar />
                <div className="flex-1 flex flex-col bg-gray-900">
                    <ChatArea />
                    <InputSection />
                </div>
            </div>
        );

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<Provider store={store}><App /></Provider>);
    </script>
</body>
</html>