<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Multi-Provider AI Chatbot</title>
    <script src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://unpkg.com/redux@4.2.1/dist/redux.min.js"></script>
    <script src="https://unpkg.com/react-redux@8.1.3/dist/react-redux.min.js"></script>
    <script src="https://unpkg.com/@reduxjs/toolkit@1.9.7/dist/redux-toolkit.umd.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap');
        body { font-family: 'Inter', sans-serif; overflow: hidden; }
        .no-scrollbar::-webkit-scrollbar { display: none; }
        .no-scrollbar { -ms-overflow-style: none; scrollbar-width: none; }
        .message-content pre { background-color: #1e293b; color: #e2e8f0; padding: 1rem; border-radius: 0.5rem; overflow-x: auto; margin: 0.5rem 0; }
        .message-content code { font-family: 'ui-monospace', 'SFMono-Regular', Menlo, Monaco, Consolas, 'Liberation Mono', 'Courier New', monospace; background-color: #334155; padding: 2px 4px; border-radius: 4px; }
        .message-content pre code { background-color: transparent; padding: 0; }
        .message-content p { margin-bottom: 0.5rem; line-height: 1.6; }
        .sidebar { transition: width 0.3s ease-in-out; }
    </style>
</head>
<body class="bg-gray-900 text-gray-100">
    <div id="root"></div>

    <script type="text/babel">
        const { Provider, useSelector, useDispatch } = ReactRedux;
        const { configureStore, createSlice, createAsyncThunk } = RTK;
        const { useState, useEffect, useRef, createContext, useContext } = React;

        const API_BASE_URL = 'http://127.0.0.1:8000';

        // --- AUTH CONTEXT & API CLIENT ---
        const AuthContext = createContext();

        const apiClient = {
            async post(endpoint, data, token = null, contentType = 'application/json') {
                const headers = { 'Content-Type': contentType };
                const authToken = token || localStorage.getItem('authToken');
                if (authToken) headers['Authorization'] = `Bearer ${authToken}`;
                
                let body;
                if (contentType === 'application/json') {
                    body = JSON.stringify(data);
                } else {
                    body = new URLSearchParams(data);
                }

                const response = await fetch(`${API_BASE_URL}${endpoint}`, { method: 'POST', headers, body });
                
                const responseData = await response.json();
                if (!response.ok) throw responseData;
                return responseData;
            },
            async get(endpoint, token) {
                const authToken = token || localStorage.getItem('authToken');
                const headers = { 'Authorization': `Bearer ${authToken}` };
                const response = await fetch(`${API_BASE_URL}${endpoint}`, { headers });
                const responseData = await response.json();
                if (!response.ok) throw responseData;
                return responseData;
            },
             async put(endpoint, data, token) {
                const headers = { 'Content-Type': 'application/json', 'Authorization': `Bearer ${token}` };
                const response = await fetch(`${API_BASE_URL}${endpoint}`, { method: 'PUT', headers, body: JSON.stringify(data) });
                const responseData = await response.json();
                if (!response.ok) throw responseData;
                return responseData;
            },
            async del(endpoint, token) {
                const headers = { 'Authorization': `Bearer ${token}` };
                const response = await fetch(`${API_BASE_URL}${endpoint}`, { method: 'DELETE', headers });
                if (!response.ok) throw await response.json();
                return response;
            }
        };

        const AuthProvider = ({ children }) => {
            const [token, setToken] = useState(() => localStorage.getItem('authToken'));
            const [user, setUser] = useState(null);
            const [loading, setLoading] = useState(true);

            useEffect(() => {
                const validateToken = async () => {
                    if (token) {
                        try {
                            const userData = await apiClient.get('/users/me/', token);
                            setUser(userData);
                        } catch (error) {
                            console.error("Session expired", error);
                            setToken(null);
                            localStorage.removeItem('authToken');
                        }
                    }
                    setLoading(false);
                };
                validateToken();
            }, [token]);

            const login = async (email, password) => {
                const data = await apiClient.post('/token', { username: email, password }, null, 'application/x-www-form-urlencoded');
                localStorage.setItem('authToken', data.access_token);
                setToken(data.access_token);
            };

            const register = async (username, email, password) => {
                await apiClient.post('/users/', { username, email, password });
                await login(email, password); // Auto-login after registration
            };

            const logout = () => {
                setToken(null);
                setUser(null);
                localStorage.removeItem('authToken');
            };

            const value = { token, user, login, register, logout, loading, apiClient };
            return <AuthContext.Provider value={value}>{children}</AuthContext.Provider>;
        };

        const useAuth = () => useContext(AuthContext);

       // --- ASYNC THUNKS ---
        const fetchSessions = createAsyncThunk('chat/fetchSessions', async (_, { getState, rejectWithValue }) => {
            try {
                return await apiClient.get('/sessions');
            } catch(e) { return rejectWithValue(e.message) }
        });

        // ... other thunks (create, update, delete session)
        const createNewSession = createAsyncThunk('chat/createNewSession', async (title) => {
            const response = await fetch(`${API_BASE_URL}/sessions`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json', 'Authorization': `Bearer ${localStorage.getItem('authToken')}` },
                body: JSON.stringify({ title: title || "New Chat" })
            });
            return response.json();
        });
        
        const fetchSessionDetails = createAsyncThunk('chat/fetchSessionDetails', async (sessionId) => {
            const response = await fetch(`${API_BASE_URL}/sessions/${sessionId}`, {
                method: 'GET',
                headers: { 'Content-Type': 'application/json', 'Authorization': `Bearer ${localStorage.getItem('authToken')}` },
            });
            return response.json();
        });

        // --- REDUX SLICE (Simplified for brevity) ---
        const chatSlice = createSlice({
            name: 'chat',
            initialState: {
                sessions: {},
                activeSessionId: null,
                isSidebarOpen: true,
                sessionStatus: 'idle', // 'idle' | 'loading' | 'succeeded' | 'failed'
                isStreaming: false,
                currentProvider: 'gemini',
                currentModel: 'gemini-pro',
            },
            reducers: {
                toggleSidebar: (state) => { state.isSidebarOpen = !state.isSidebarOpen; },
                // ... other reducers
                startStream: (state, action) => {
                    const { sessionId, userMessage } = action.payload;
                    state.isStreaming = true;
                    // Optimistically add user message and AI placeholder
                    state.sessions[sessionId].messages.push(userMessage);
                    state.sessions[sessionId].messages.push({ id: `ai-${Date.now()}`, role: 'assistant', content: '' });
                },
                appendStream: (state, action) => {
                    const { sessionId, delta } = action.payload;
                    const session = state.sessions[sessionId];
                    if (session) {
                        const lastMessage = session.messages[session.messages.length - 1];
                        if (lastMessage?.role === 'assistant') {
                            lastMessage.content += delta;
                        }
                    }
                },
                endStream: (state, action) => {
                    // When streaming ends, we fetch the final state from the server
                    // to ensure consistency and get the real message ID.
                    state.isStreaming = false;
                },
                setActiveSessionId: (state, action) => {
                    state.activeSessionId = action.payload;
                },
                 setModelAndProvider: (state, action) => {
                    state.currentProvider = action.payload.provider;
                    state.currentModel = action.payload.model;
                }
            },
            extraReducers: (builder) => {
                builder.addCase(fetchSessions.fulfilled, (state, action) => {
                    state.sessions = action.payload.reduce((acc, s) => { acc[s.id] = s; return acc; }, {});
                    if (!state.activeSessionId && action.payload.length > 0) {
                        state.activeSessionId = action.payload[0].id;
                    }
                    state.sessionStatus = 'succeeded';
                })
                .addCase(fetchSessions.pending, (state) => {
                    state.sessionStatus = 'loading';
                })
                .addCase(fetchSessions.rejected, (state) => {
                    state.sessionStatus = 'failed';
                })
                .addCase(createNewSession.fulfilled, (state, action) => {
                    const newSession = action.payload;
                    state.sessions[newSession.id] = newSession;
                    state.activeSessionId = newSession.id;
                })
                .addCase(fetchSessionDetails.fulfilled, (state, action) => {
                    const session = action.payload;
                    state.sessions[session.id] = session;
                });
                // ... other extraReducers
            }
        });

        const { toggleSidebar, startStream, appendStream, endStream, setActiveSessionId, setModelAndProvider } = chatSlice.actions;

        // --- Main Redux Store ---
        const store = configureStore({
            reducer: { 
                chat: chatSlice.reducer
            } 
        });

        // --- API & STREAMING LOGIC ---
        let eventSource = null;

        const streamChatResponse = (payload) => async (dispatch) => {
            const { sessionId, prompt, provider, model } = payload;
            
            const userMessage = { id: `user-${Date.now()}`, role: 'user', content: prompt };
            dispatch(startStream({ sessionId, userMessage }));

            const response = await fetch(`${API_BASE_URL}/chat/stream`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json', 'Authorization': `Bearer ${localStorage.getItem('authToken')}` },
                body: JSON.stringify({ session_id: sessionId, prompt, provider, model })
            });
            
            const reader = response.body.getReader();
            const decoder = new TextDecoder();

            const processStream = async () => {
                while (true) {
                    const { done, value } = await reader.read();
                    if (done) break;

                    const chunk = decoder.decode(value, { stream: true });
                    const events = chunk.split('\n\n').filter(Boolean);

                    for (const event of events) {
                        if (event.startsWith('data: ')) {
                            const dataStr = event.substring(6);
                            if (dataStr === "[DONE]") {
                                dispatch(endStream());
                                // Fetch final message from server to sync state
                                dispatch(fetchSessionDetails(sessionId)); 
                                return;
                            }
                            try {
                                const data = JSON.parse(dataStr);
                                if (data.delta) {
                                    dispatch(appendStream({ sessionId, delta: data.delta }));
                                }
                                if (data.error) {
                                    console.error("Stream error:", data.error);
                                    dispatch(endStream());
                                    dispatch(fetchSessionDetails(sessionId));
                                    return;
                                }
                            } catch (e) {
                                console.error("JSON parse error", e);
                            }
                        }
                    }
                }
            };
            processStream();
        };

        // --- COMPONENTS ---
        const AuthForm = () => {
            const [isLogin, setIsLogin] = useState(true);
            const [email, setEmail] = useState('');
            const [password, setPassword] = useState('');
            const [username, setUsername] = useState('');
            const [error, setError] = useState(null);
            const [loading, setLoading] = useState(false);
            const { login, register } = useAuth();

            const handleSubmit = async (e) => {
                e.preventDefault();
                setError(null);
                setLoading(true);
                try {
                    if (isLogin) {
                        await login(email, password);
                    } else {
                        await register(username, email, password);
                    }
                } catch (err) {
                    setError(err.detail || 'An unexpected error occurred.');
                } finally {
                    setLoading(false);
                }
            };

            return (
                <div className="flex items-center justify-center h-screen bg-gray-900">
                    <div className="w-full max-w-md p-8 space-y-8 bg-gray-800 rounded-lg shadow-lg">
                        <div>
                            <h2 className="text-3xl font-extrabold text-center text-white">
                                {isLogin ? 'Sign in to your account' : 'Create a new account'}
                            </h2>
                            <p className="mt-2 text-sm text-center text-gray-400">
                                or&nbsp;
                                <a href="#" onClick={() => setIsLogin(!isLogin)} className="font-medium text-indigo-400 hover:text-indigo-300">
                                    {isLogin ? 'create an account' : 'sign in instead'}
                                </a>
                            </p>
                        </div>
                        <form className="mt-8 space-y-6" onSubmit={handleSubmit}>
                            {!isLogin && (
                                <input
                                    type="text"
                                    value={username}
                                    onChange={(e) => setUsername(e.target.value)}
                                    className="w-full px-3 py-2 text-white bg-gray-700 border border-gray-600 rounded-md focus:outline-none focus:ring-2 focus:ring-indigo-500"
                                    placeholder="Username"
                                    required
                                />
                            )}
                            <input
                                type="email"
                                value={email}
                                onChange={(e) => setEmail(e.target.value)}
                                className="w-full px-3 py-2 text-white bg-gray-700 border border-gray-600 rounded-md focus:outline-none focus:ring-2 focus:ring-indigo-500"
                                placeholder="Email address"
                                required
                            />
                            <input
                                type="password"
                                value={password}
                                onChange={(e) => setPassword(e.target.value)}
                                className="w-full px-3 py-2 mt-4 text-white bg-gray-700 border border-gray-600 rounded-md focus:outline-none focus:ring-2 focus:ring-indigo-500"
                                placeholder="Password"
                                required
                            />
                            {error && <p className="text-sm text-red-400">{error}</p>}
                            <div>
                                <button
                                    type="submit"
                                    disabled={loading}
                                    className="relative flex justify-center w-full px-4 py-2 text-sm font-medium text-white bg-indigo-600 border border-transparent rounded-md group hover:bg-indigo-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-indigo-500 disabled:bg-indigo-400"
                                >
                                    {loading ? 'Processing...' : (isLogin ? 'Sign in' : 'Create account')}
                                </button>
                            </div>
                        </form>
                    </div>
                </div>
            );
        };

        const ProviderSelector = () => {
            // ... (Component remains the same as before)
            const dispatch = useDispatch();
            const currentProvider = useSelector(state => state.chat.currentProvider);
            const currentModel = useSelector(state => state.chat.currentModel);
            const [isOpen, setIsOpen] = useState(false);

            const providers = {
                openai: ['gpt-3.5-turbo', 'gpt-4.1'],
                anthropic: ['claude-3-haiku', 'claude-3-sonnet'],
                gemini: ['gemini-pro', 'gemini-flash'],
                ollama: ['llama3', 'mistral']
            };

            const handleSelect = (provider, model) => {
                dispatch(setModelAndProvider({ provider, model }));
                setIsOpen(false);
            };

            return (
                <div className="relative">
                    <button onClick={() => setIsOpen(!isOpen)} className="w-full bg-gray-700 hover:bg-gray-600 text-left px-4 py-2 rounded-lg transition-colors duration-200 flex justify-between items-center">
                        <div>
                            <span className="font-semibold capitalize">{currentProvider}</span>
                            <span className="text-gray-400 ml-2">{currentModel}</span>
                        </div>
                        <svg className={`w-5 h-5 transition-transform duration-200 ${isOpen ? 'transform rotate-180' : ''}`} fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M19 9l-7 7-7-7"></path></svg>
                    </button>
                    {isOpen && (
                        <div className="absolute bottom-full mb-2 w-full bg-gray-800 border border-gray-700 rounded-lg shadow-lg z-10">
                            {Object.entries(providers).map(([provider, models]) => (
                                <div key={provider}>
                                    <h3 className="text-sm font-bold text-gray-400 px-4 pt-3 capitalize">{provider}</h3>
                                    <ul>
                                        {models.map(model => (
                                            <li key={model} onClick={() => handleSelect(provider, model)} className="px-4 py-2 hover:bg-gray-700 cursor-pointer rounded-md">
                                                {model}
                                            </li>
                                        ))}
                                    </ul>
                                </div>
                            ))}
                        </div>
                    )}
                </div>
            );
        };
        
        const Sidebar = () => {
            const dispatch = useDispatch();
            const sessions = useSelector(state => Object.values(state.chat.sessions));
            const activeSessionId = useSelector(state => state.chat.activeSessionId);
            const sessionStatus = useSelector(state => state.chat.sessionStatus);

            useEffect(() => {
                if (sessionStatus === 'idle') {
                    dispatch(fetchSessions());
                }
            }, [sessionStatus, dispatch]);
            
            const handleSetActive = (sessionId) => {
                dispatch(setActiveSessionId(sessionId));
                dispatch(fetchSessionDetails(sessionId));
            }

            return (
                <div className="w-64 bg-gray-800 h-full flex flex-col p-3">
                    <div className="flex items-center justify-between mb-4">
                        <h1 className="text-xl font-bold">Chat AI</h1>
                        <button onClick={() => dispatch(createNewSession())} className="p-2 rounded-md hover:bg-gray-700">
                            <svg className="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M12 6v6m0 0v6m0-6h6m-6 0H6"></path></svg>
                        </button>
                    </div>
                    <div className="flex-grow overflow-y-auto no-scrollbar pr-1">
                        <p className="text-xs text-gray-500 font-semibold mb-2 px-2">RECENT</p>
                        {sessionStatus === 'loading' && <p className="text-sm text-gray-400 px-2">Loading sessions...</p>}
                        {sessions.length === 0 && <p className="text-sm text-gray-400 px-2">No sessions yet. Click + to start a new chat.</p>}
                        {sessions.map(session => (
                            <div key={session.id} onClick={() => handleSetActive(session.id)}
                                className={`truncate px-3 py-2 rounded-md cursor-pointer text-sm mb-1 ${activeSessionId === session.id ? 'bg-gray-700' : 'hover:bg-gray-700/50'}`}>
                                {session.title}
                            </div>
                        ))}
                    </div>
                    <div className="mt-auto">
                        <ProviderSelector />
                    </div>
                </div>
            );
        };

        const ChatMessage = ({ message }) => {
             // ... (Component remains the same as before)
            const isUser = message.role === 'user';
            
            const renderContent = (content) => {
                let html = content
                    .replace(/```([\s\S]*?)```/g, (match, code) => `<pre><code>${code.trim().replace(/</g, "&lt;").replace(/>/g, "&gt;")}</code></pre>`)
                    .replace(/`([^`]+)`/g, `<code>$1</code>`)
                    .replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>')
                    .replace(/\*(.*?)\*/g, '<em>$1</em>')
                    .replace(/\n/g, '<br />');
                
                html = html.replace(/<br \/>\s*(<pre>)/g, '$1').replace(/(<\/pre>)\s*<br \/>/g, '$1');
                return { __html: html };
            };

            return (
                <div className={`flex items-start gap-4 my-4 ${isUser ? 'pr-10' : ''}`}>
                    <div className={`w-8 h-8 rounded-full flex-shrink-0 ${isUser ? 'bg-blue-500' : 'bg-green-500'} flex items-center justify-center font-bold`}>
                        {isUser ? 'U' : 'AI'}
                    </div>
                    <div className="flex-grow mt-1 message-content" dangerouslySetInnerHTML={renderContent(message.content || "")} />
                </div>
            );
        };

        const ChatArea = () => {
            const activeSessionId = useSelector(state => state.chat.activeSessionId);
            const session = useSelector(state => state.chat.sessions[activeSessionId]);
            const messagesEndRef = useRef(null);

            useEffect(() => {
                messagesEndRef.current?.scrollIntoView({ behavior: "smooth" });
            }, [session?.messages]);

            if (!session) {
                return <div className="flex-1 flex items-center justify-center"><p>Select or create a new session.</p></div>;
            }

            return (
                <div className="flex-1 flex flex-col">
                    <div className="flex-grow overflow-y-auto p-6 no-scrollbar">
                        {session.messages.map((msg) => (
                            <ChatMessage key={msg.id} message={msg} />
                        ))}
                        <div ref={messagesEndRef} />
                    </div>
                </div>
            );
        };

        const InputSection = () => {
            const [input, setInput] = useState('');
            const dispatch = useDispatch();
            const isStreaming = useSelector(state => state.chat.isStreaming);
            const activeSessionId = useSelector(state => state.chat.activeSessionId);
            const { currentProvider, currentModel } = useSelector(state => state.chat);

            const handleSend = () => {
                if (input.trim() && !isStreaming && activeSessionId) {
                    dispatch(streamChatResponse({
                        sessionId: activeSessionId,
                        prompt: input,
                        provider: currentProvider,
                        model: currentModel
                    }));
                    setInput('');
                }
            };
            
            // The stop button now has no function as the new streaming logic doesn't use EventSource
            const handleStop = () => console.log("Stop functionality to be re-implemented.");

            const handleKeyDown = (e) => { if (e.key === 'Enter' && !e.shiftKey) { e.preventDefault(); handleSend(); }};

            return (
                <div className="p-6 bg-gray-900">
                    <div className="relative bg-gray-800 border border-gray-700 rounded-lg p-2 flex items-center">
                        <textarea
                            value={input}
                            onChange={(e) => setInput(e.target.value)}
                            onKeyDown={handleKeyDown}
                            placeholder="Type your message..."
                            rows="1"
                            className="w-full bg-transparent resize-none outline-none p-2 no-scrollbar"
                            disabled={isStreaming || !activeSessionId}
                        />
                         {isStreaming ? (
                            <button onClick={handleStop} className="bg-red-500 text-white font-bold py-2 px-4 rounded-md flex items-center" disabled>
                                <svg className="w-4 h-4 mr-2" fill="currentColor" viewBox="0 0 16 16"><path d="M5 3.5h6A1.5 1.5 0 0 1 12.5 5v6a1.5 1.5 0 0 1-1.5 1.5H5A1.5 1.5 0 0 1 3.5 11V5A1.5 1.5 0 0 1 5 3.5z"/></svg>
                                Stop
                            </button>
                        ) : (
                            <button onClick={handleSend} className="bg-blue-500 hover:bg-blue-600 text-white font-bold py-2 px-4 rounded-md" disabled={!input.trim() || !activeSessionId}>
                                Send
                            </button>
                        )}
                    </div>
                </div>
            );
        };

        const ChatApp = () => {
            const { token, logout } = useAuth();
            const dispatch = useDispatch();
            const isSidebarOpen = useSelector(state => state.chat.isSidebarOpen);

            useEffect(() => {
                if (token) {
                    dispatch(fetchSessions());
                }
            }, [token, dispatch]);

            return (
                <div className="flex h-screen w-screen">
                    <Sidebar />
                    <div className="flex-1 flex flex-col bg-gray-900 transition-all duration-300" style={{ marginLeft: isSidebarOpen ? '16rem' : '0' }}>
                        <ChatArea />
                        <InputSection />
                    </div>
                </div>
            );
        };

        // const ChatApp = () => {
        //     // This is a placeholder for your main chat application UI.
        //     // You would integrate your Sidebar, ChatArea, etc., here.
        //     const { user, logout } = useAuth();

        //     return (
        //          <div className="flex flex-col items-center justify-center h-screen">
        //             <h1 className="text-4xl">Welcome, {user?.username || 'User'}!</h1>
        //             <p className="text-gray-400">This is the main chat application.</p>
        //             <button 
        //                 onClick={logout}
        //                 className="px-4 py-2 mt-8 font-bold text-white bg-red-600 rounded hover:bg-red-700"
        //             >
        //                 Logout
        //             </button>
        //         </div>
        //     );
        // };

        const App = () => {
            const { token, loading } = useAuth();

            if (loading) {
                return (
                    <div className="flex items-center justify-center h-screen">
                        <div className="w-16 h-16 border-4 border-dashed rounded-full animate-spin border-indigo-500"></div>
                    </div>
                );
            }

            return token ? <ChatApp /> : <AuthForm isLogin={true}/>;
        };

        // --- RENDER ---
        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(
            <Provider store={store}>
                <AuthProvider>
                    <App />
                </AuthProvider>
            </Provider>
        );
    </script>
</body>
</html>