<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Multi-Provider AI Chatbot</title>
    <script src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://unpkg.com/redux@4.2.1/dist/redux.min.js"></script>
    <script src="https://unpkg.com/react-redux@8.1.3/dist/react-redux.min.js"></script>
    <script src="https://unpkg.com/@reduxjs/toolkit@1.9.7/dist/redux-toolkit.umd.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap');
        html, body, #root { height: 100%; overflow: hidden; }
        body { font-family: 'Inter', sans-serif; }
        .no-scrollbar::-webkit-scrollbar { display: none; }
        .no-scrollbar { -ms-overflow-style: none; scrollbar-width: none; }
        .message-content pre { background-color: #1e293b; color: #e2e8f0; padding: 1rem; border-radius: 0.5rem; overflow-x: auto; margin: 0.5rem 0; }
        .message-content code { font-family: 'ui-monospace', 'SFMono-Regular', Menlo, Monaco, Consolas, 'Liberation Mono', 'Courier New', monospace; background-color: #334155; padding: 2px 4px; border-radius: 4px; }
        .message-content pre code { background-color: transparent; padding: 0; }
        .message-content p { margin-bottom: 0.5rem; line-height: 1.6; }
        .sidebar { transition: width 0.3s ease-in-out; }
    </style>
</head>
<body class="bg-gray-900 text-gray-100">
    <div id="root"></div>

    <script type="text/babel">
        const { Provider, useSelector, useDispatch } = ReactRedux;
        const { configureStore, createSlice, createAsyncThunk } = RTK;
        const { useState, useEffect, useRef, createContext, useContext } = React;

        const API_BASE_URL = 'http://127.0.0.1:8000';

        // --- AUTH CONTEXT & API CLIENT ---
        const AuthContext = createContext();

        const apiClient = {
            async post(endpoint, data, token, contentType = 'application/json') {
                const headers = { 'Content-Type': contentType };
                if (token) headers['Authorization'] = `Bearer ${token}`;
                
                let body;
                if (contentType === 'application/json') { body = JSON.stringify(data); } 
                else { body = new URLSearchParams(data); }

                const response = await fetch(`${API_BASE_URL}${endpoint}`, { method: 'POST', headers, body });
                const responseData = await response.json();
                if (!response.ok) throw responseData;
                return responseData;
            },
            async get(endpoint, token) {
                const headers = { 'Authorization': `Bearer ${token}` };
                const response = await fetch(`${API_BASE_URL}${endpoint}`, { headers });
                const responseData = await response.json();
                if (!response.ok) throw responseData;
                return responseData;
            },
             async put(endpoint, data, token) {
                const headers = { 'Content-Type': 'application/json', 'Authorization': `Bearer ${token}` };
                const response = await fetch(`${API_BASE_URL}${endpoint}`, { method: 'PUT', headers, body: JSON.stringify(data) });
                const responseData = await response.json();
                if (!response.ok) throw responseData;
                return responseData;
            },
            async del(endpoint, token) {
                const headers = { 'Authorization': `Bearer ${token}` };
                const response = await fetch(`${API_BASE_URL}${endpoint}`, { method: 'DELETE', headers });
                if (response.status !== 204 && !response.ok) throw await response.json();
                return response;
            }
        };

        const AuthProvider = ({ children }) => { 
            const [token, setToken] = useState(() => localStorage.getItem('authToken'));
            const [user, setUser] = useState(null);
            const [loading, setLoading] = useState(true);

            useEffect(() => {
                const validateToken = async () => {
                    if (token) {
                        try {
                            const userData = await apiClient.get('/users/me/', token);
                            setUser(userData);
                        } catch (error) {
                            console.error("Session expired", error);
                            setToken(null);
                            localStorage.removeItem('authToken');
                        }
                    }
                    setLoading(false);
                };
                validateToken();
            }, [token]);

            const login = async (email, password) => {
                const data = await apiClient.post('/token', { username: email, password }, null, 'application/x-www-form-urlencoded');
                localStorage.setItem('authToken', data.access_token);
                setToken(data.access_token);
            };

            const register = async (username, email, password) => {
                await apiClient.post('/users/', { username, email, password });
                await login(email, password);
            };

            const logout = () => {
                setToken(null);
                setUser(null);
                localStorage.removeItem('authToken');
            };

            const value = { token, user, login, register, logout, loading, apiClient };
            return <AuthContext.Provider value={value}>{children}</AuthContext.Provider>;
        };

        const useAuth = () => useContext(AuthContext);

        // --- REDUX THUNKS ---
        const fetchSessions = createAsyncThunk('chat/fetchSessions', async (_, { extra: { apiClient, token } }) => apiClient.get('/sessions', token));
        const createNewSession = createAsyncThunk('chat/createNewSession', async (title, { extra: { apiClient, token } }) => apiClient.post('/sessions', { title }, token));
        const fetchSessionDetails = createAsyncThunk('chat/fetchSessionDetails', async (sessionId, { extra: { apiClient, token } }) => apiClient.get(`/sessions/${sessionId}`, token));
        const updateSessionTitle = createAsyncThunk('chat/updateSessionTitle', async ({ sessionId, title }, { extra: { apiClient, token } }) => apiClient.put(`/sessions/${sessionId}`, { title }, token));
        const deleteSession = createAsyncThunk('chat/deleteSession', async (sessionId, { extra: { apiClient, token } }) => {
            await apiClient.del(`/sessions/${sessionId}`, token);
            return sessionId;
        });

        // --- REDUX SLICE ---
        const chatSlice = createSlice({
            name: 'chat',
            initialState: {
                sessions: {},
                activeSessionId: null,
                isSidebarOpen: true,
                sessionStatus: 'idle', // 'idle' | 'loading' | 'succeeded' | 'failed'
                isStreaming: false,
                currentProvider: 'gemini',
                currentModel: 'gemini-pro',
            },
            reducers: {
                toggleSidebar: (state) => { state.isSidebarOpen = !state.isSidebarOpen; },
                startStream: (state, action) => {
                    const { sessionId, userMessage } = action.payload;
                    state.isStreaming = true;
                    // Optimistically add user message and AI placeholder
                    state.sessions[sessionId].messages.push(userMessage);
                    state.sessions[sessionId].messages.push({ id: `ai-${Date.now()}`, role: 'assistant', content: '' });
                },
                appendStream: (state, action) => {
                    const { sessionId, delta } = action.payload;
                    const lastMessage = state.sessions[sessionId]?.messages.slice(-1)[0];
                    if (lastMessage?.role === 'assistant') lastMessage.content += delta;
                },
                endStream: (state) => { state.isStreaming = false; },
                setActiveSessionId: (state, action) => { state.activeSessionId = action.payload; },
                setModelAndProvider: (state, action) => {
                    state.currentProvider = action.payload.provider;
                    state.currentModel = action.payload.model;
                },
            },
            extraReducers: (builder) => {
                builder
                    .addCase(fetchSessions.pending, (state) => { state.sessionStatus = 'loading'; })
                    .addCase(fetchSessions.fulfilled, (state, action) => {
                        state.sessionStatus = 'succeeded';
                        state.sessions = action.payload.reduce((acc, session) => {
                            acc[session.id] = { ...session, messages: [] };
                            return acc;
                        }, {});
                        if (!state.activeSessionId && action.payload.length > 0) {
                            state.activeSessionId = action.payload[0].id;
                        }
                    })
                    .addCase(fetchSessions.rejected, (state) => {
                        state.sessionStatus = 'failed';
                    })
                    .addCase(createNewSession.fulfilled, (state, action) => {
                        const newSession = action.payload;
                        state.sessions[newSession.id] = { ...newSession, messages: [] };
                        state.activeSessionId = newSession.id;
                    })
                    .addCase(fetchSessionDetails.fulfilled, (state, action) => {
                        state.sessions[action.payload.id] = action.payload;
                    })
                    .addCase(updateSessionTitle.fulfilled, (state, action) => {
                        state.sessions[action.payload.id].title = action.payload.title;
                    })
                    .addCase(deleteSession.fulfilled, (state, action) => {
                        delete state.sessions[action.payload];
                        if (state.activeSessionId === action.payload) {
                            state.activeSessionId = Object.keys(state.sessions)[0] || null;
                        }
                    });
            }
        });

        const { toggleSidebar, startStream, appendStream, endStream, setActiveSessionId, setModelAndProvider } = chatSlice.actions;

        // --- REDUX STORE ---
        const store = configureStore({
            reducer: { 
                chat: chatSlice.reducer,
                auth: (state = { token: localStorage.getItem('authToken') }) => state
            },
            middleware: (getDefaultMiddleware) => getDefaultMiddleware({
                thunk: { extraArgument: { apiClient, token: localStorage.getItem('authToken') } }
            }),
        });

        // --- STREAMING LOGIC ---
        const streamChatResponse = (payload) => async (dispatch, getState) => {
            const { token } = getState().auth;
            const { sessionId, prompt, provider, model } = payload;
            const userMessage = { id: `user-${Date.now()}`, role: 'user', content: prompt };

            dispatch(startStream({ sessionId, userMessage }));

            const response = await fetch(`${API_BASE_URL}/chat/stream`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json', 'Authorization': `Bearer ${token}` },
                body: JSON.stringify({ session_id: sessionId, prompt, provider, model })
            });
            const reader = response.body.getReader();
            const decoder = new TextDecoder();

            while (true) {
                const { done, value } = await reader.read();
                if (done) break;
                const chunk = decoder.decode(value, { stream: true });
                const events = chunk.split('\n\n').filter(Boolean);
                for (const event of events) {
                    if (event.startsWith('data: ')) {
                        const dataStr = event.substring(6);
                        if (dataStr === "[DONE]") {
                            dispatch(endStream());
                            dispatch(fetchSessionDetails(sessionId));
                            return;
                        }
                        try {
                            const data = JSON.parse(dataStr);
                            if (data.delta) dispatch(appendStream({ sessionId, delta: data.delta }));
                            if (data.error) {
                                console.error("Stream error:", data.error);
                                dispatch(endStream());
                                dispatch(fetchSessionDetails(sessionId));
                                return;
                            }
                        } catch (e) { console.error("JSON parse error", e); }
                    }
                }
            }
        };
        
        // --- COMPONENTS ---
        const AuthForm = () => {  
            const [isLogin, setIsLogin] = useState(true);
            const [email, setEmail] = useState('');
            const [password, setPassword] = useState('');
            const [username, setUsername] = useState('');
            const [error, setError] = useState(null);
            const [loading, setLoading] = useState(false);
            const { login, register } = useAuth();

            const handleSubmit = async (e) => {
                e.preventDefault();
                setError(null);
                setLoading(true);
                try {
                    if (isLogin) {
                        await login(email, password);
                    } else {
                        await register(username, email, password);
                    }
                } catch (err) {
                    setError(err.detail || 'An unexpected error occurred.');
                } finally {
                    setLoading(false);
                }
            };

            return (
                <div className="flex items-center justify-center h-screen bg-gray-900">
                    <div className="w-full max-w-md p-8 space-y-8 bg-gray-800 rounded-lg shadow-lg">
                        <div>
                            <h2 className="text-3xl font-extrabold text-center text-white">
                                {isLogin ? 'Sign in to your account' : 'Create a new account'}
                            </h2>
                            <p className="mt-2 text-sm text-center text-gray-400">
                                or&nbsp;
                                <a href="#" onClick={() => setIsLogin(!isLogin)} className="font-medium text-indigo-400 hover:text-indigo-300">
                                    {isLogin ? 'create an account' : 'sign in instead'}
                                </a>
                            </p>
                        </div>
                        <form className="mt-8 space-y-6" onSubmit={handleSubmit}>
                            {!isLogin && (
                                <input type="text" value={username} onChange={(e) => setUsername(e.target.value)} className="w-full px-3 py-2 text-white bg-gray-700 border border-gray-600 rounded-md focus:outline-none focus:ring-2 focus:ring-indigo-500" placeholder="Username" required />
                            )}
                            <input type="email" value={email} onChange={(e) => setEmail(e.target.value)} className="w-full px-3 py-2 text-white bg-gray-700 border border-gray-600 rounded-md focus:outline-none focus:ring-2 focus:ring-indigo-500" placeholder="Email address" required />
                            <input type="password" value={password} onChange={(e) => setPassword(e.target.value)} className="w-full px-3 py-2 mt-4 text-white bg-gray-700 border border-gray-600 rounded-md focus:outline-none focus:ring-2 focus:ring-indigo-500" placeholder="Password" required />
                            {error && <p className="text-sm text-red-400">{error}</p>}
                            <div>
                                <button type="submit" disabled={loading} className="relative flex justify-center w-full px-4 py-2 text-sm font-medium text-white bg-indigo-600 border border-transparent rounded-md group hover:bg-indigo-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-indigo-500 disabled:bg-indigo-400">
                                    {loading ? 'Processing...' : (isLogin ? 'Sign in' : 'Create account')}
                                </button>
                            </div>
                        </form>
                    </div>
                </div>
            );
        };
        
        const ProviderSelector = () => { 
            const dispatch = useDispatch();
            const { currentProvider, currentModel } = useSelector(state => state.chat);
            const [isOpen, setIsOpen] = useState(false);
            const providers = { 
                openai: ['gpt-3.5-turbo', 'gpt-4.1'],
                anthropic: ['claude-3-haiku', 'claude-3-sonnet'],
                gemini: ['gemini-pro', 'gemini-flash'],
                ollama: ['llama3', 'mistral']
            };
            const handleSelect = (provider, model) => {
                dispatch(setModelAndProvider({ provider, model }));
                setIsOpen(false);
            };
            return (
                <div className="relative">
                    <button onClick={() => setIsOpen(!isOpen)} className="w-full bg-gray-700 hover:bg-gray-600 text-left px-4 py-2 rounded-lg transition-colors duration-200 flex justify-between items-center">
                        <div>
                            <span className="font-semibold capitalize">{currentProvider}</span>
                            <span className="text-gray-400 ml-2">{currentModel}</span>
                        </div>
                        <svg className={`w-5 h-5 transition-transform duration-200 ${isOpen ? 'transform rotate-180' : ''}`} fill="none" stroke="currentColor" viewBox="0 0 24 24"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M19 9l-7 7-7-7"></path></svg>
                    </button>
                    {isOpen && (
                        <div className="absolute bottom-full mb-2 w-full bg-gray-800 border border-gray-700 rounded-lg shadow-lg z-10 p-2">
                            {Object.entries(providers).map(([provider, models]) => (
                                <div key={provider}>
                                    <h3 className="text-sm font-bold text-gray-400 px-2 pt-2 capitalize">{provider}</h3>
                                    <ul>
                                        {models.map(model => (
                                        <li key={model} onClick={() => handleSelect(provider, model)} className="px-2 py-2 text-sm hover:bg-gray-700 cursor-pointer rounded-md">{model}</li>
                                        ))}
                                    </ul>
                                </div>
                            ))}
                        </div>
                    )}
                </div>
            );
        };
        
        const Sidebar = () => {
            const dispatch = useDispatch();
            const { user, logout } = useAuth();
            const sessions = useSelector(state => Object.values(state.chat.sessions).sort((a,b) => new Date(b.created_at) - new Date(a.created_at)));
            const activeSessionId = useSelector(state => state.chat.activeSessionId);
            const sessionStatus = useSelector(state => state.chat.sessionStatus);

            useEffect(() => {
                if (sessionStatus === 'idle') dispatch(fetchSessions());
            }, [sessionStatus, dispatch]);
            
            const handleSetActive = (sessionId) => {
                // if (sessionId !== activeSessionId) {
                    dispatch(setActiveSessionId(sessionId));
                    dispatch(fetchSessionDetails(sessionId));
                // }
            }

            return (
                <div className="w-64 bg-gray-800 h-full flex flex-col p-3">
                    <div className="flex items-center justify-between mb-4">
                        <h1 className="text-xl font-bold">Chat AI</h1>
                        <button onClick={() => dispatch(createNewSession('New Chat'))} className="p-2 rounded-md hover:bg-gray-700">
                            <svg className="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M12 6v6m0 0v6m0-6h6m-6 0H6"></path></svg>
                        </button>
                    </div>
                    <div className="flex-grow overflow-y-auto no-scrollbar pr-1">
                        <p className="text-xs text-gray-500 font-semibold mb-2 px-2">RECENT</p>
                        {sessionStatus === 'loading' && <p>Loading...</p>}
                        {sessions.map(session => (
                            <div key={session.id} onClick={() => handleSetActive(session.id)}
                                 className={`truncate px-3 py-2 rounded-md cursor-pointer text-sm mb-1 ${activeSessionId === session.id ? 'bg-gray-700' : 'hover:bg-gray-700/50'}`}>
                                 {session.title}
                            </div>
                        ))}
                    </div>
                    <div className="mt-auto flex flex-col gap-4">
                        <ProviderSelector />
                        <div className="border-t border-gray-700 pt-3">
                            <div className="flex items-center justify-between">
                                <span className="text-sm truncate">{user?.email}</span>
                                <button onClick={logout} className="p-2 rounded-md hover:bg-gray-700">
                                    <svg className="w-5 h-5 text-red-400" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M17 16l4-4m0 0l-4-4m4 4H7m6 4v1a3 3 0 01-3 3H6a3 3 0 01-3-3V7a3 3 0 013-3h4a3 3 0 013 3v1"></path></svg>
                                </button>
                            </div>
                        </div>
                    </div>
                </div>
            );
        };

        const ChatMessage = ({ message }) => {  
            const isUser = message.role === 'user';
            const renderContent = (content) => {
                let html = content
                    .replace(/</g, "&lt;")
                    .replace(/>/g, "&gt;");
                html = html.replace(/```([\s\S]*?)```/g, (match, code) => `<pre><code>${code.trim()}</code></pre>`).replace(/`([^`]+)`/g, `<code>$1</code>`).replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>').replace(/\n/g, '<br />');
                return { __html: html.replace(/<br \/>\s*(<pre>)/g, '$1').replace(/(<\/pre>)\s*<br \/>/g, '$1') };
            };
            return (
                <div className={`flex items-start gap-4 my-6`}>
                    <div className={`w-8 h-8 rounded-full flex-shrink-0 ${isUser ? 'bg-indigo-500' : 'bg-green-500'} flex items-center justify-center font-bold text-sm`}>
                        {isUser ? 'U' : 'AI'}
                    </div>
                    <div className="flex-grow mt-1 message-content" dangerouslySetInnerHTML={renderContent(message.content || "")} />
                </div>
            );
        };

        const ChatArea = () => {
            const activeSessionId = useSelector(state => state.chat.activeSessionId);
            const session = useSelector(state => state.chat.sessions[activeSessionId]);
            const messagesEndRef = useRef(null);

            useEffect(() => {
                messagesEndRef.current?.scrollIntoView({ behavior: "smooth" });
            }, [session?.messages]);

            if (!session) { 
                return <div className="flex-1 flex items-center justify-center"><p>Select or create a new session to begin.</p></div>; 
            }
            return (
                <div className="flex-1 overflow-y-auto p-6">
                    {session.messages?.map((msg) => (
                        <ChatMessage key={msg.id} message={msg} />
                    ))}
                    <div ref={messagesEndRef} />
                </div>
            );
        };

        const InputSection = () => {
            const [input, setInput] = useState('');
            const dispatch = useDispatch();
            const { isStreaming, activeSessionId, currentProvider, currentModel } = useSelector(state => state.chat);
            const handleSend = () => {
                if (input.trim() && !isStreaming && activeSessionId) {
                    dispatch(streamChatResponse({
                         sessionId: activeSessionId, 
                         prompt: input, 
                         provider: currentProvider, 
                         model: currentModel 
                    }));
                    setInput('');
                }
            };
            const handleKeyDown = (e) => { if (e.key === 'Enter' && !e.shiftKey) { e.preventDefault(); handleSend(); }};
            return (
                <div className="p-6 bg-gray-900/50 backdrop-blur-sm">
                    <div className="relative bg-gray-800 border border-gray-700 rounded-lg p-2 flex items-center">
                        <textarea 
                            value={input} 
                            onChange={(e) => setInput(e.target.value)} 
                            onKeyDown={handleKeyDown} 
                            placeholder="Type your message..." rows="1" className="w-full bg-transparent resize-none outline-none p-2 no-scrollbar" 
                            disabled={isStreaming || !activeSessionId} 
                        />
                        {isStreaming ? (
                            <button className="bg-red-500 text-white font-bold py-2 px-4 rounded-md flex items-center" disabled>
                                <svg className="animate-spin h-5 w-5 mr-3" viewBox="0 0 24 24"><circle className="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" strokeWidth="4"></circle><path className="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path></svg>
                                Stop
                            </button>
                        ) : (
                            <button onClick={handleSend} className="bg-indigo-500 hover:bg-indigo-600 text-white font-bold py-2 px-4 rounded-md disabled:bg-indigo-400/50" disabled={!input.trim() || !activeSessionId}>
                                Send
                            </button>
                        )}
                    </div>
                </div>
            );
        };

        const ChatApp = () => {
            const dispatch = useDispatch();
            const { token } = useAuth();
            useEffect(() => {
                 if (token) dispatch(fetchSessions()); 
            }, [token, dispatch]);
            return (
                <div className="flex h-full w-full">
                    <Sidebar />
                    <div className="flex-1 flex flex-col bg-gray-900">
                        <ChatArea />
                        <InputSection />
                    </div>
                </div>
            );
        };

        const App = () => {
            const { token, loading } = useAuth();
            if (loading) { 
                return (
                    <div className="flex items-center justify-center h-screen">
                        <div className="w-16 h-16 border-4 border-dashed rounded-full animate-spin border-indigo-500"></div>
                    </div>
                ); 
            }
            return token ? <ChatApp /> : <AuthForm />;
        };

        // --- RENDER ---
        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(
            <Provider store={store}>
                <AuthProvider>
                    <App />
                </AuthProvider>
            </Provider>
        );
    </script>
</body>
</html>

