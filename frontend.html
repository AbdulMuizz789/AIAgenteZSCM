<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Multi-Provider AI Chatbot</title>
    <script src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://unpkg.com/redux@4.2.1/dist/redux.min.js"></script>
    <script src="https://unpkg.com/react-redux@8.1.3/dist/react-redux.min.js"></script>
    <script src="https://unpkg.com/@reduxjs/toolkit@1.9.7/dist/redux-toolkit.umd.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap');
        body {
            font-family: 'Inter', sans-serif;
            overflow: hidden;
        }
        .no-scrollbar::-webkit-scrollbar { display: none; }
        .no-scrollbar { -ms-overflow-style: none; scrollbar-width: none; }
        .message-content p { margin-bottom: 0.5rem; }
        .message-content ol, .message-content ul { margin-left: 1.5rem; margin-bottom: 0.5rem; }
        .message-content pre {
            background-color: #1e293b;
            color: #e2e8f0;
            padding: 1rem;
            border-radius: 0.5rem;
            overflow-x: auto;
            margin-bottom: 0.5rem;
        }
        .message-content code {
            font-family: 'Courier New', Courier, monospace;
        }
    </style>
</head>
<body class="bg-gray-900 text-gray-100">
    <div id="root"></div>

    <script type="text/babel">
        const { Provider, useSelector, useDispatch } = ReactRedux;
        const { configureStore, createSlice } = RTK;
        const { useState, useEffect, useRef } = React;

        // --- REDUX SLICE ---
        const chatSlice = createSlice({
            name: 'chat',
            initialState: {
                sessions: { 'session-1': { id: 'session-1', title: 'Welcome Chat', messages: [{ id: 'msg-1', role: 'assistant', content: 'Hello! How can I help you today?' }] } },
                activeSessionId: 'session-1',
                isStreaming: false,
                currentProvider: 'gemini', // Default provider
                currentModel: 'gemini-pro', // Default model
            },
            reducers: {
                addMessage: (state, action) => {
                    const { sessionId, message } = action.payload;
                    state.sessions[sessionId].messages.push(message);
                },
                startStream: (state, action) => {
                    state.isStreaming = true;
                    const { sessionId, message } = action.payload;
                    if (!state.sessions[sessionId]) {
                        state.sessions[sessionId] = { id: sessionId, title: "New Chat", messages: [] };
                    }
                    state.sessions[sessionId].messages.push(message); // User message
                    state.sessions[sessionId].messages.push({ id: `ai-${Date.now()}`, role: 'assistant', content: '' }); // Placeholder for AI
                },
                appendStream: (state, action) => {
                    const { sessionId, delta } = action.payload;
                    const session = state.sessions[sessionId];
                    if (session) {
                        const lastMessage = session.messages[session.messages.length - 1];
                        if (lastMessage && lastMessage.role === 'assistant') {
                            lastMessage.content += delta;
                        }
                    }
                },
                endStream: (state) => {
                    state.isStreaming = false;
                },
                newSession: (state) => {
                    const newSessionId = `session-${Date.now()}`;
                    state.sessions[newSessionId] = { id: newSessionId, title: 'New Chat', messages: [] };
                    state.activeSessionId = newSessionId;
                },
                setActiveSession: (state, action) => {
                    state.activeSessionId = action.payload;
                },
                setModelAndProvider: (state, action) => {
                    state.currentProvider = action.payload.provider;
                    state.currentModel = action.payload.model;
                }
            }
        });

        const { addMessage, startStream, appendStream, endStream, newSession, setActiveSession, setModelAndProvider } = chatSlice.actions;

        // --- REDUX STORE ---
        const store = configureStore({
            reducer: {
                chat: chatSlice.reducer
            }
        });
        
        // --- API & STREAMING LOGIC ---
        let eventSource = null;

        const streamChatResponse = (payload) => (dispatch) => {
            const { sessionId, messages, provider, model } = payload;
            
            dispatch(startStream({ 
                sessionId, 
                message: messages[messages.length - 1] // Pass user message
            }));

            // Replace with your actual backend endpoint
            const API_URL = 'http://127.0.0.1:8000/chat/stream';

            eventSource = new EventSource(`${API_URL}?prompt=${encodeURIComponent(messages[messages.length-1].content)}&provider=${provider}&model=${model}`);

            eventSource.onmessage = (event) => {
                if (event.data === "[DONE]") {
                    dispatch(endStream());
                    eventSource.close();
                    return;
                }
                const data = JSON.parse(event.data);
                if (data.delta) {
                    dispatch(appendStream({ sessionId, delta: data.delta }));
                }
            };

            eventSource.onerror = (err) => {
                console.error("EventSource failed:", err);
                dispatch(endStream());
                eventSource.close();
            };
        };

        const stopStreaming = () => (dispatch) => {
            if (eventSource) {
                eventSource.close();
                dispatch(endStream());
            }
        };


        // --- COMPONENTS ---

        const ProviderSelector = () => {
            const dispatch = useDispatch();
            const currentProvider = useSelector(state => state.chat.currentProvider);
            const currentModel = useSelector(state => state.chat.currentModel);
            const [isOpen, setIsOpen] = useState(false);

            const providers = {
                openai: ['gpt-3.5-turbo', 'gpt-4.1'],
                anthropic: ['claude-3-haiku', 'claude-3-sonnet'],
                gemini: ['gemini-pro', 'gemini-flash'],
                ollama: ['llama3', 'mistral']
            };

            const handleSelect = (provider, model) => {
                dispatch(setModelAndProvider({ provider, model }));
                setIsOpen(false);
            };

            return (
                <div className="relative">
                    <button onClick={() => setIsOpen(!isOpen)} className="w-full bg-gray-700 hover:bg-gray-600 text-left px-4 py-2 rounded-lg transition-colors duration-200 flex justify-between items-center">
                        <div>
                            <span className="font-semibold capitalize">{currentProvider}</span>
                            <span className="text-gray-400 ml-2">{currentModel}</span>
                        </div>
                        <svg className={`w-5 h-5 transition-transform duration-200 ${isOpen ? 'transform rotate-180' : ''}`} fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M19 9l-7 7-7-7"></path></svg>
                    </button>
                    {isOpen && (
                        <div className="absolute bottom-full mb-2 w-full bg-gray-800 border border-gray-700 rounded-lg shadow-lg z-10">
                            {Object.entries(providers).map(([provider, models]) => (
                                <div key={provider}>
                                    <h3 className="text-sm font-bold text-gray-400 px-4 pt-3 capitalize">{provider}</h3>
                                    <ul>
                                        {models.map(model => (
                                            <li key={model} onClick={() => handleSelect(provider, model)} className="px-4 py-2 hover:bg-gray-700 cursor-pointer rounded-md">
                                                {model}
                                            </li>
                                        ))}
                                    </ul>
                                </div>
                            ))}
                        </div>
                    )}
                </div>
            );
        };

        const Sidebar = () => {
            const dispatch = useDispatch();
            const sessions = useSelector(state => state.chat.sessions);
            const activeSessionId = useSelector(state => state.chat.activeSessionId);
            
            return (
                <div className="w-64 bg-gray-800 h-full flex flex-col p-3">
                    <div className="flex items-center justify-between mb-4">
                        <h1 className="text-xl font-bold">Chat AI</h1>
                        <button onClick={() => dispatch(newSession())} className="p-2 rounded-md hover:bg-gray-700">
                            <svg className="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M12 6v6m0 0v6m0-6h6m-6 0H6"></path></svg>
                        </button>
                    </div>
                    <div className="flex-grow overflow-y-auto no-scrollbar pr-1">
                        <p className="text-xs text-gray-500 font-semibold mb-2 px-2">RECENT</p>
                        {Object.values(sessions).map(session => (
                            <div key={session.id} onClick={() => dispatch(setActiveSession(session.id))}
                                className={`truncate px-3 py-2 rounded-md cursor-pointer text-sm mb-1 ${activeSessionId === session.id ? 'bg-gray-700' : 'hover:bg-gray-700/50'}`}>
                                {session.title}
                            </div>
                        ))}
                    </div>
                    <div className="mt-auto">
                        <ProviderSelector />
                    </div>
                </div>
            );
        };

        const ChatMessage = ({ message }) => {
            const isUser = message.role === 'user';
            
            // A simple markdown-to-html converter
            const renderContent = (content) => {
                let html = content
                    .replace(/```([\s\S]*?)```/g, (match, code) => `<pre><code>${code.trim()}</code></pre>`)
                    .replace(/`([^`]+)`/g, `<code>$1</code>`)
                    .replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>')
                    .replace(/\*(.*?)\*/g, '<em>$1</em>')
                    .replace(/\n/g, '<br />');
                
                // This is a simplified replacement, a real implementation would be more robust
                html = html.replace(/<br \/>\s*(<pre>)/g, '$1');
                html = html.replace(/(<\/pre>)\s*<br \/>/g, '$1');

                return { __html: html };
            };

            return (
                <div className={`flex items-start gap-4 my-4 ${isUser ? 'pr-10' : ''}`}>
                    <div className={`w-8 h-8 rounded-full flex-shrink-0 ${isUser ? 'bg-blue-500' : 'bg-green-500'} flex items-center justify-center font-bold`}>
                        {isUser ? 'U' : 'AI'}
                    </div>
                    <div className="flex-grow mt-1 message-content" dangerouslySetInnerHTML={renderContent(message.content)} />
                </div>
            );
        };

        const ChatArea = () => {
            const activeSessionId = useSelector(state => state.chat.activeSessionId);
            const session = useSelector(state => state.chat.sessions[activeSessionId]);
            const messagesEndRef = useRef(null);

            useEffect(() => {
                messagesEndRef.current?.scrollIntoView({ behavior: "smooth" });
            }, [session?.messages]);

            if (!session) {
                return <div className="flex-1 flex items-center justify-center"><p>Select or create a new session.</p></div>;
            }

            return (
                <div className="flex-1 flex flex-col">
                    <div className="flex-grow overflow-y-auto p-6 no-scrollbar">
                        {session.messages.map((msg, index) => (
                            <ChatMessage key={msg.id || index} message={msg} />
                        ))}
                        <div ref={messagesEndRef} />
                    </div>
                </div>
            );
        };

        const InputSection = () => {
            const [input, setInput] = useState('');
            const dispatch = useDispatch();
            const isStreaming = useSelector(state => state.chat.isStreaming);
            const activeSessionId = useSelector(state => state.chat.activeSessionId);
            const { currentProvider, currentModel } = useSelector(state => state.chat);

            const handleSend = () => {
                if (input.trim() && !isStreaming) {
                    const userMessage = { id: `user-${Date.now()}`, role: 'user', content: input };
                    
                    dispatch(streamChatResponse({
                        sessionId: activeSessionId,
                        messages: [userMessage], // In a real app, you'd send context
                        provider: currentProvider,
                        model: currentModel
                    }));
                    setInput('');
                }
            };

            const handleStop = () => {
                dispatch(stopStreaming());
            };

            const handleKeyDown = (e) => {
                if (e.key === 'Enter' && !e.shiftKey) {
                    e.preventDefault();
                    handleSend();
                }
            };

            return (
                <div className="p-6 bg-gray-900">
                    <div className="relative bg-gray-800 border border-gray-700 rounded-lg p-2 flex items-center">
                        <textarea
                            value={input}
                            onChange={(e) => setInput(e.target.value)}
                            onKeyDown={handleKeyDown}
                            placeholder="Type your message..."
                            rows="1"
                            className="w-full bg-transparent resize-none outline-none p-2 no-scrollbar"
                            style={{ maxHeight: '100px' }}
                            disabled={isStreaming}
                        />
                        {isStreaming ? (
                            <button onClick={handleStop} className="bg-red-500 hover:bg-red-600 text-white font-bold py-2 px-4 rounded-md flex items-center">
                                <svg className="w-4 h-4 mr-2" fill="currentColor" viewBox="0 0 16 16"><path d="M5 3.5h6A1.5 1.5 0 0 1 12.5 5v6a1.5 1.5 0 0 1-1.5 1.5H5A1.5 1.5 0 0 1 3.5 11V5A1.5 1.5 0 0 1 5 3.5z"/></svg>
                                Stop
                            </button>
                        ) : (
                            <button onClick={handleSend} className="bg-blue-500 hover:bg-blue-600 text-white font-bold py-2 px-4 rounded-md" disabled={!input.trim()}>
                                Send
                            </button>
                        )}
                    </div>
                </div>
            );
        };

        // --- APP LAYOUT ---
        const App = () => {
            return (
                <div className="flex h-screen w-screen">
                    <Sidebar />
                    <div className="flex-1 flex flex-col bg-gray-900">
                        <ChatArea />
                        <InputSection />
                    </div>
                </div>
            );
        };

        // --- RENDER APP ---
        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(
            <Provider store={store}>
                <App />
            </Provider>
        );
    </script>
</body>
</html>